# Poplar Virtual Machine

This virtual machine (VM) implementation for the Poplar language is designed to run on the Agon platform. It interprets hexadecimal ASCII bytecode files (.ppx) generated by the Poplar compiler.

## Features

- Implements the complete Poplar bytecode instruction set
- Human-readable hexadecimal ASCII bytecode format
- Stack-based architecture with 16-bit integer support
- Simple heap memory management
- Support for function calls with stack frames
- While loop control structures
- Basic error handling

## Memory Model

The VM has several memory areas:

- **vmStack**: Main stack for operations (1024 16-bit cells)
- **vmTemp**: Temporary stack used during frame operations (256 16-bit cells)
- **vmHeap**: Dynamic memory allocation area (4096 bytes)
- **outputBuffer**: Buffer for output operations
- **inChar**: Holds the latest keyboard input character

## Instruction Set

### Stack Operations

- `PUSHN n:i16`: Push a 16-bit integer onto the stack

### Binary Operations

- `ADD`: Pop two values a, b; push a+b
- `SUB`: Pop two values a, b; push a-b
- `MUL`: Pop two values a, b; push a*b
- `DIV`: Pop two values a, b; push a/b
- `MOD`: Pop two values a, b; push a%b
- `SIGN`: Pop value a; push 1 if a â‰¥ 0, otherwise push -1

### Memory Management

- `ALLOCATE`: Pop size; allocate size bytes on heap; push pointer
- `FREE`: Pop pointer, size; free memory (currently a no-op)
- `STORE size:i24`: Pop pointer; pop size bytes; store at pointer
- `LOAD size:i24`: Pop pointer; push size; push size bytes from pointer

### Control Flow

- `BEGIN_WHILE`: Pop condition; if zero, skip to matching END_WHILE
- `END_WHILE`: Jump back to matching BEGIN_WHILE
- `CALL fn:i16`: Call function by ID
- `LOAD_FRAME_PTR`: Push current frame pointer onto stack
- `MAKE_STACK_FRAME argSize:i8 localSize:i8`: Create new stack frame
- `DROP_STACK_FRAME returnSize:i8 localSize:i8`: Drop stack frame

## Bytecode Format

The bytecode is stored in a human-readable hexadecimal ASCII format, where:

1. Each byte is represented by two hexadecimal characters (e.g., '00' for PUSHN opcode)
2. Whitespace and line breaks are ignored and can be used for readability
3. Comments can be added by starting a line with '#'

The logical structure of the bytecode consists of:

1. An opcode byte
2. Optional parameters depending on the opcode:
   - 16-bit integers (2 bytes in little-endian)
   - 24-bit integers (3 bytes in little-endian)
   - 8-bit values

### Example Bytecode

```
# Simple math program: Calculate 1+2*3
# PUSHN 1
00 0100

# PUSHN 2
00 0200

# PUSHN 3
00 0300

# MUL (2*3)
04

# ADD (1+(2*3))
01
```

## Usage

```
poplarvm program.ppx
```

You can create or edit .ppx files in any text editor since they are in hexadecimal ASCII format. This makes debugging and inspecting bytecode much easier.

## Limitations and Future Work

- Memory management is very simple with no true freeing of memory
- Error handling could be improved
- No optimization of bytecode execution
- Function calls are not fully implemented in the current version
- No support for floating-point operations

## Building

The VM can be built using the provided Makefile:

```
make
```

This will generate the `poplarvm` executable that can run Poplar bytecode files.
